import { LeadStatus, ConnectionTestResult, Database, Salesperson, Lead, LeadActivity, Role, Program, SalespersonWithStats } from './types.ts';
import { supabase } from './supabaseClient.ts';
import jsPDF from 'jspdf';
import 'jspdf-autotable';

type LeadInsert = Database['public']['Tables']['leads']['Insert'];
type LeadUpdate = Database['public']['Tables']['leads']['Update'];
type SalespersonInsert = Database['public']['Tables']['profiles']['Insert'];
type SalespersonUpdate = Database['public']['Tables']['profiles']['Update'];

// --- Constants ---
export const statusColors: { [key in LeadStatus]: string } = {
    [LeadStatus.New]: 'bg-blue-500',
    [LeadStatus.Uncalled]: 'bg-orange-500',
    [LeadStatus.Contacted]: 'bg-yellow-500',
    [LeadStatus.FollowUp]: 'bg-purple-500',
    [LeadStatus.Won]: 'bg-green-500',
    [LeadStatus.Lost]: 'bg-red-500',
};
export const leadStatuses = Object.values(LeadStatus);

// --- LINE NOTIFICATION CONFIG ---
const LINE_CHANNEL_ACCESS_TOKEN = 'P3MUI6dxMEaFKR8LYT0GbSZBcbV3bjvOTWA/tgTistte1TOXvagwyf6XidI/ZOy3NwIGaEXIO7xbzIxESiKXUdI39CBXH7GjTM4xlVk0x0DpZYVml3W75mFF05PUWvdJ8EnCEsDY87ihcLBxHf876QdB04t89/1O/w1cDnyilFU=';
const LINE_TARGET_ID = 'Cfe28bbc3dacaaf3d7981625b99f80c7d'; // Group ID
const APP_URL = 'https://lead-application-theta.vercel.app/';

// --- SQL SCRIPTS (Exported for UI use) ---

export const RLS_LEADS_FIX = `-- This script resets RLS for the 'leads' table.
DROP POLICY IF EXISTS "Admins can manage all leads." ON public.leads;
DROP POLICY IF EXISTS "Admins can insert new leads." ON public.leads;
DROP POLICY IF EXISTS "Sales can view their own assigned leads." ON public.leads;
DROP POLICY IF EXISTS "Sales can update their own assigned leads." ON public.leads;
DROP POLICY IF EXISTS "Sales can delete their own assigned leads." ON public.leads;

CREATE POLICY "Admins can manage all leads." ON public.leads FOR ALL USING (get_my_role() = 'admin');
CREATE POLICY "Admins can insert new leads." ON public.leads FOR INSERT WITH CHECK (get_my_role() = 'admin');
CREATE POLICY "Sales can view their own assigned leads." ON public.leads FOR SELECT USING (assigned_to = auth.uid());
CREATE POLICY "Sales can update their own assigned leads." ON public.leads FOR UPDATE USING (assigned_to = auth.uid());
CREATE POLICY "Sales can delete their own assigned leads." ON public.leads FOR DELETE USING (assigned_to = auth.uid());`;

export const RLS_PROFILES_FIX = `-- This script resets RLS for the 'profiles' table.
DROP POLICY IF EXISTS "Admins can manage all profiles." ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;

CREATE POLICY "Admins can manage all profiles." ON public.profiles FOR ALL USING (get_my_role() = 'admin');
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);`;

export const RLS_CALENDAR_FIX = `-- This script resets RLS for the 'calendar_events' table.
DROP POLICY IF EXISTS "Admins can manage all calendar events." ON public.calendar_events;
DROP POLICY IF EXISTS "Sales can manage their own calendar events." ON public.calendar_events;

CREATE POLICY "Admins can manage all calendar events." ON public.calendar_events FOR ALL USING (get_my_role() = 'admin');
CREATE POLICY "Sales can manage their own calendar events." ON public.calendar_events FOR ALL USING (salesperson_id = auth.uid()) WITH CHECK (salesperson_id = auth.uid());`;

export const SQL_CREATE_PROGRAMS = `-- Create the programs table and policies
CREATE TABLE IF NOT EXISTS public.programs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

ALTER TABLE public.programs ENABLE ROW LEVEL SECURITY;

-- Policies
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'programs' AND policyname = 'Everyone can read programs') THEN
        CREATE POLICY "Everyone can read programs" ON public.programs FOR SELECT USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'programs' AND policyname = 'Admins can manage programs') THEN
        CREATE POLICY "Admins can manage programs" ON public.programs FOR ALL USING (get_my_role() = 'admin');
    END IF;
END $$;`;

export const SQL_UPDATE_USER_PASSWORD_FIX = `-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Admin ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏´‡πâ User ‡∏≠‡∏∑‡πà‡∏ô
create extension if not exists "pgcrypto";

create or replace function update_user_password(user_id uuid, new_password text)
returns void
language plpgsql
security definer
as $$
begin
  update auth.users
  set encrypted_password = crypt(new_password, gen_salt('bf'))
  where id = user_id;
end;
$$;`;

export const SQL_ADMIN_CREATE_USER = `-- Enable pgcrypto if not already enabled
create extension if not exists "pgcrypto";

-- Drop existing function to ensure clean update of parameters/logic
DROP FUNCTION IF EXISTS admin_create_user(text, text, text, text);

-- Function to create user
create or replace function admin_create_user(email_input text, password_input text, full_name_input text, role_input text)
returns uuid
language plpgsql
security definer
as $$
declare
  new_user_id uuid;
begin
  -- Check if user exists
  if exists (select 1 from auth.users where email = email_input) then
    raise exception 'User with this email already exists';
  end if;

  -- Create user in auth.users
  insert into auth.users (
    instance_id,
    id,
    aud,
    role,
    email,
    encrypted_password,
    email_confirmed_at,
    raw_app_meta_data,
    raw_user_meta_data,
    created_at,
    updated_at
  )
  values (
    '00000000-0000-0000-0000-000000000000',
    gen_random_uuid(),
    'authenticated',
    'authenticated',
    email_input,
    crypt(password_input, gen_salt('bf')),
    now(),
    '{"provider":"email","providers":["email"]}',
    json_build_object('full_name', full_name_input, 'role', role_input),
    now(),
    now()
  )
  returning id into new_user_id;

  -- Create identity (Required for login to work properly)
  insert into auth.identities (
    id,
    user_id,
    identity_data,
    provider,
    provider_id,
    last_sign_in_at,
    created_at,
    updated_at
  )
  values (
    gen_random_uuid(),
    new_user_id,
    json_build_object('sub', new_user_id, 'email', email_input, 'email_verified', true, 'phone_verified', false),
    'email',
    new_user_id::text,
    now(),
    now(),
    now()
  );

  -- Ensure profile exists (in case trigger didn't catch it or for robustness)
  insert into public.profiles (id, full_name, role, email)
  values (new_user_id, full_name_input, role_input, email_input)
  on conflict (id) do update
  set full_name = excluded.full_name,
      role = excluded.role,
      email = excluded.email;

  return new_user_id;
end;
$$;`;

// --- Data Services ---

export const getLeads = async (role: 'admin' | 'sales', userId?: string) => {
    let query = supabase
      .from('leads')
      .select(`
        *,
        profiles (
            full_name
        )
      `)
      .order('received_date', { ascending: false });

    if (role === 'sales' && userId) {
        query = query.eq('assigned_to', userId);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data;
};

export const getUnreadLeadsCount = async (userId: string) => {
    const { count, error } = await supabase
        .from('leads')
        .select('*', { count: 'exact', head: true })
        .eq('assigned_to', userId)
        .in('status', ['‡πÉ‡∏´‡∏°‡πà', '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÇ‡∏ó‡∏£']);
    if (error) {
        console.error("Error fetching unread leads count:", error);
        return 0;
    }
    return count ?? 0;
};

export const createLead = async (leadData: LeadInsert) => {
    const { data, error } = await supabase.from('leads').insert(leadData).select().single();
    if (error) throw error;
    return data;
};

export const updateLead = async (id: number, leadData: LeadUpdate) => {
    const { data, error } = await supabase.from('leads').update(leadData).eq('id', id).select().single();
    if (error) throw error;
    return data;
};

export const deleteLead = async (id: number) => {
    const { error } = await supabase.from('leads').delete().eq('id', id);
    if (error) throw error;
};

export const getSalesTeam = async (): Promise<Salesperson[]> => {
    const { data, error } = await supabase.from('profiles').select('*').order('full_name');
    if (error) throw error;
    return data;
};

export const adminCreateUser = async (userData: { fullName: string, email: string, password: string, role: Role }) => {
    const { error } = await supabase.rpc('admin_create_user', {
        email_input: userData.email,
        password_input: userData.password,
        full_name_input: userData.fullName,
        role_input: userData.role,
    });
    if (error) throw error;
};

export const updateSalesperson = async (id: string, salespersonData: SalespersonUpdate) => {
     const { error } = await supabase.from('profiles').update(salespersonData).eq('id', id);
    if (error) throw error;
};

export const updateUserPassword = async (userId: string, newPassword: string) => {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user && user.id === userId) {
        const { error } = await supabase.auth.updateUser({ password: newPassword });
        if (error) throw error;
        return;
    }

    const { error } = await supabase.rpc('update_user_password', {
        user_id: userId,
        new_password: newPassword
    });
    if (error) throw error;
};


export const deleteSalesperson = async (id: string) => {
     const { error } = await supabase.from('profiles').delete().eq('id', id);
    if (error) throw error;
};

export const getCalendarEvents = async (role: 'admin' | 'sales', userId: string) => {
    // 1. Fetch Manual Appointments
    let query = supabase.from('calendar_events').select('*, leads(name)');
     if (role === 'sales') {
        query = query.eq('salesperson_id', userId);
    }
    const { data: appointments, error } = await query;
    if (error) throw error;

    // 2. Fetch Leads for Bookings and Birthdays
    let leadsQuery = supabase.from('leads').select('id, name, received_date, birthday, program, assigned_to');
    if (role === 'sales') {
        leadsQuery = leadsQuery.eq('assigned_to', userId);
    }
    const { data: leads, error: leadsError } = await leadsQuery;
    if (leadsError) throw leadsError;

    const events = [...(appointments || [])];

    // 3. Map Leads to Events
    leads?.forEach((lead) => {
        // Booking Event (‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏á)
        if (lead.received_date) {
            events.push({
                id: -lead.id, // Negative ID to distinguish
                title: `${lead.name} (${lead.program || 'N/A'})`,
                start_time: lead.received_date,
                end_time: lead.received_date,
                salesperson_id: lead.assigned_to,
                lead_id: lead.id,
                leads: { name: lead.name },
                type: 'booking' // Custom type
            } as any);
        }

        // Birthday Event (Current Year)
        if (lead.birthday) {
             const bday = new Date(lead.birthday);
             const today = new Date();
             const currentYearBday = new Date(today.getFullYear(), bday.getMonth(), bday.getDate());
             
             // If birthday passed this year but we are viewing next year? 
             // Simplification: Just show for current year.
             
             events.push({
                id: -(lead.id + 1000000), // Distinct ID
                title: `üéÇ HBD ${lead.name}`,
                start_time: currentYearBday.toISOString(),
                end_time: currentYearBday.toISOString(),
                salesperson_id: lead.assigned_to,
                lead_id: lead.id,
                leads: { name: lead.name },
                type: 'birthday' // Custom type
            } as any);
        }
    });

    return events;
};

export const createFollowUpAppointments = async (leadId: number, salespersonId: string, serviceDate: string, leadName: string) => {
    const date = new Date(serviceDate);
    const followUps = [
        { label: '‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏• 1 ‡∏ß‡∏±‡∏ô', offsetMonth: 0, offsetDay: 1 },
        { label: '‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏• 1 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', offsetMonth: 1, offsetDay: 0 },
        { label: '‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏• 3 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', offsetMonth: 3, offsetDay: 0 },
        { label: '‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏• 6 ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô', offsetMonth: 6, offsetDay: 0 },
        { label: '‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏• 1 ‡∏õ‡∏µ', offsetMonth: 12, offsetDay: 0 },
    ];

    const events = followUps.map(item => {
        const d = new Date(date);
        d.setMonth(d.getMonth() + item.offsetMonth);
        d.setDate(d.getDate() + item.offsetDay);
        
        return {
            title: `${item.label}`,
            start_time: d.toISOString(),
            end_time: new Date(d.getTime() + 60 * 60 * 1000).toISOString(),
            salesperson_id: salespersonId,
            lead_id: leadId
        };
    });

    const { error } = await supabase.from('calendar_events').insert(events);
    if (error) throw error;
};

export const getDashboardStats = async (role: 'admin' | 'sales', userId?: string, dateRange?: { start: string, end: string }) => {
    if(role === 'admin') {
        let leadsQuery = supabase.from('leads').select('value, status, created_at');
        if (dateRange) {
            leadsQuery = leadsQuery.gte('created_at', dateRange.start).lte('created_at', dateRange.end);
        }
        const { data: leads, error: leadsError } = await leadsQuery;
        if (leadsError) throw leadsError;

        const { count: teamSize, error: teamError } = await supabase.from('profiles').select('*', { count: 'exact', head: true });
        if (teamError) throw teamError;
        
        const wonLeads = leads.filter(l => l.status === LeadStatus.Won);
        
        return {
            totalLeads: leads.length,
            newLeads: leads.filter(l => new Date(l.created_at) >= new Date(new Date().toDateString())).length,
            totalValue: wonLeads.reduce((sum, lead) => sum + (lead.value || 0), 0),
            teamSize: teamSize ?? 0,
            conversionRate: leads.length > 0 ? Math.round((wonLeads.length / leads.length) * 100) : 0,
        }
    } else {
        const { data: salesLeads, error } = await supabase.from('leads').select('status, value').eq('assigned_to', userId!);
        if (error) throw error;

        const wonLeads = salesLeads.filter(l => l.status === LeadStatus.Won);
        const monthlySales = wonLeads.reduce((sum, lead) => sum + (lead.value || 0), 0);

        return {
            totalLeads: salesLeads.length,
            uncalledLeads: salesLeads.filter(l => l.status === LeadStatus.Uncalled).length,
            monthlySales: monthlySales,
            conversionRate: salesLeads.length > 0 ? Math.round((wonLeads.length / salesLeads.length) * 100) : 0
        }
    }
};

export const getSalesPerformance = async (dateRange?: { start: string, end: string }) => {
    const { data: profiles, error: profileError } = await supabase.from('profiles').select('id, full_name').eq('role', 'sales');
    if (profileError) throw profileError;
    
    let leadsQuery = supabase.from('leads').select('assigned_to, value, status, created_at').eq('status', '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
    if (dateRange) {
        leadsQuery = leadsQuery.gte('created_at', dateRange.start).lte('created_at', dateRange.end);
    }
    const { data: leads, error: leadError } = await leadsQuery;
    if (leadError) throw leadError;

    return profiles.map(sales => {
        const salesLeads = leads.filter(lead => lead.assigned_to === sales.id);
        return {
            name: (sales.full_name || 'N/A').split(' ')[0],
            sales: salesLeads.reduce((sum, lead) => sum + (lead.value || 0), 0),
            leads: salesLeads.length
        }
    });
};

export const getSalesTeamPerformance = async (): Promise<SalespersonWithStats[]> => {
    const { data: profiles, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .in('role', ['sales', 'after_care']);
    if (profileError) throw profileError;

    const { data: leads, error: leadError } = await supabase
        .from('leads')
        .select('assigned_to, value, status');
    if (leadError) throw leadError;

    const performanceData = profiles.map(salesperson => {
        const salespersonLeads = leads.filter(lead => lead.assigned_to === salesperson.id);
        
        const wonLeads = salespersonLeads.filter(l => l.status === LeadStatus.Won);
        const lostLeads = salespersonLeads.filter(l => l.status === LeadStatus.Lost);
        const uncalledLeads = salespersonLeads.filter(l => l.status === LeadStatus.Uncalled);
        
        const totalSales = wonLeads.reduce((sum, lead) => sum + (lead.value || 0), 0);
        const totalLeads = salespersonLeads.length;
        
        const conversionRate = totalLeads > 0 ? Math.round((wonLeads.length / totalLeads) * 100) : 0;

        return {
            ...salesperson,
            totalSales: totalSales,
            totalLeads: totalLeads,
            uncalledLeads: uncalledLeads.length,
            wonLeads: wonLeads.length,
            lostLeads: lostLeads.length,
            conversionRate: conversionRate
        };
    });

    return performanceData.sort((a, b) => b.totalSales - a.totalSales);
};

export const getConversionRates = async (salespersonId?: string, dateRange?: { start: string, end: string }) => {
    let query = supabase.from('leads').select('status, created_at');
    if (salespersonId) {
        query = query.eq('assigned_to', salespersonId);
    }
    if (dateRange) {
        query = query.gte('created_at', dateRange.start).lte('created_at', dateRange.end);
    }
    const { data: leads, error } = await query;
    if (error) throw error;
    
    const won = leads.filter(l => l.status === LeadStatus.Won).length;
    const lost = leads.filter(l => l.status === LeadStatus.Lost).length;
    const inProgress = leads.length - won - lost;
    return [
        { name: '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', value: won },
        { name: '‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å', value: lost },
        { name: '‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡∏π‡πà', value: inProgress },
    ];
};

export const getSalesTrend = async (dateRange?: { start: string, end: string }) => {
    return [
        { name: '‡∏°.‡∏Ñ.', sales: 120000 },
        { name: '‡∏Å.‡∏û.', sales: 150000 },
        { name: '‡∏°‡∏µ.‡∏Ñ.', sales: 130000 },
        { name: '‡πÄ‡∏°.‡∏¢.', sales: 180000 },
        { name: '‡∏û.‡∏Ñ.', sales: 210000 },
        { name: '‡∏°‡∏¥.‡∏¢.', sales: 190000 },
    ];
};

export const getBirthdays = async (salespersonId?: string) => {
    let query = supabase.from('leads').select('id, name, birthday, phone');
    if (salespersonId) {
        query = query.eq('assigned_to', salespersonId);
    }
    const { data, error } = await query;
    if (error) throw error;

    const relevantLeads = data.filter(l => l.birthday);

    const todayDate = new Date();
    const todayLeads = relevantLeads.filter(l => {
        const bday = new Date(l.birthday!);
        return bday.getUTCDate() === todayDate.getUTCDate() && bday.getUTCMonth() === todayDate.getUTCMonth();
    });
    const thisMonthLeads = relevantLeads.filter(l => {
        const bday = new Date(l.birthday!);
        return bday.getUTCMonth() === todayDate.getUTCMonth();
    });
    return { today: todayLeads, thisMonth: thisMonthLeads };
}

// --- Program Services ---
export const getPrograms = async (): Promise<Program[]> => {
    const { data, error } = await supabase.from('programs').select('*').order('name');
    if (error) throw error;
    return data;
};

export const createProgram = async (name: string) => {
    const { error } = await supabase.from('programs').insert({ name });
    if (error) throw error;
};

export const deleteProgram = async (id: number) => {
    const { error } = await supabase.from('programs').delete().eq('id', id);
    if (error) throw error;
};

// --- Lead Activity Services ---
export const getLeadActivities = async (leadId: number): Promise<LeadActivity[]> => {
    const { data, error } = await supabase
        .from('lead_activities')
        .select('*')
        .eq('lead_id', leadId)
        .order('created_at', { ascending: false });
    if (error) throw error;
    return data;
};

export const createLeadActivity = async (leadId: number, description: string) => {
    const { data: { user } } = await supabase.auth.getUser();
    const { data: profile } = await supabase.from('profiles').select('full_name').eq('id', user?.id).single();
    
    const activityData = {
        lead_id: leadId,
        activity_description: description,
        user_id: user?.id,
        user_name: profile?.full_name || user?.email,
    };
    const { error } = await supabase.from('lead_activities').insert(activityData);
    if (error) throw error;
};

// --- Export Services ---

export const exportToCSV = (data: any[], filename?: string) => {
    if (!data || !data.length) return;
    
    // Define headers manually to ensure order and specific fields
    const headers = ['ID', 'Date', 'Name', 'Phone', 'Program', 'Status', 'Value', 'Assigned To', 'Address', 'Notes'];
    
    const csvRows = [headers.join(',')];

    for (const row of data) {
        const values = [
            row.id,
            row.received_date ? new Date(row.received_date).toLocaleDateString('th-TH') : '',
            `"${(row.name || '').replace(/"/g, '""')}"`,
            `"${(row.phone || '').replace(/"/g, '""')}"`,
            `"${(row.program || '').replace(/"/g, '""')}"`,
            row.status,
            row.value || 0,
            `"${(row.profiles?.full_name || row.assigned_to || '').replace(/"/g, '""')}"`,
            `"${(row.address || '').replace(/"/g, '""')}"`,
            `"${(row.notes || '').replace(/"/g, '""')}"`,
        ];
        csvRows.push(values.join(','));
    }

    const blob = new Blob(["\uFEFF" + csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `export_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export const exportToPDF = (data: any[], filename?: string) => {
    const doc = new jsPDF();
    
    // Note: Thai characters might not render correctly without a custom font.
    // Using standard font for compatibility.
    
    doc.setFontSize(18);
    doc.text("Leads Export", 14, 22);
    doc.setFontSize(10);
    doc.text(`Generated on: ${new Date().toLocaleDateString('th-TH')}`, 14, 28);
    
    const tableColumn = ["Date", "Name", "Phone", "Program", "Status", "Sales", "Value"];
    const tableRows: any[] = [];

    data.forEach(lead => {
        const leadData = [
            lead.received_date ? new Date(lead.received_date).toLocaleDateString('th-TH') : '',
            lead.name || '',
            lead.phone || '',
            lead.program || '',
            lead.status || '',
            lead.profiles?.full_name || '',
            (lead.value || 0).toLocaleString(),
        ];
        tableRows.push(leadData);
    });

    (doc as any).autoTable({
        head: [tableColumn],
        body: tableRows,
        startY: 35,
        styles: { fontSize: 8 }, 
        headStyles: { fillColor: [14, 165, 233] }, // Sky-500
    });
    
    doc.save(filename || `export_${new Date().toISOString().split('T')[0]}.pdf`);
};

// --- LINE Messaging API Integration ---

type LineNotificationType = 'new_lead' | 'update_status' | 'delete_lead' | 'birthday' | 'test' | 'idle_leads' | 'reassign_leads' | 'followup_reminder' | 'birthday_report';

interface LineNotificationData {
    leadName?: string;
    program?: string | null;
    status?: string;
    salesName?: string | null;
    phone?: string;
    receivedDate?: string;
    address?: string | null;
    notes?: string | null;
    leads?: Lead[]; // Deprecated for birthday, use specific fields below
    // New fields for complex reports
    leadsList?: any[]; // For Idle/Reassign reports
    birthdaysToday?: any[];
    birthdaysMonth?: any[];
    followUps?: any[];
}

export const sendLineNotification = async (type: LineNotificationType, data: LineNotificationData) => {
    // Use a CORS proxy to bypass browser restrictions for demo purposes.
    const lineApiUrl = 'https://api.line.me/v2/bot/message/push';
    const url = `https://corsproxy.io/?${encodeURIComponent(lineApiUrl)}`;
    
    let headerColor = '#0ea5e9'; // Default Blue
    let headerTitle = '‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô';
    let altText = 'CRM Notification';
    let statusColor = '#666666';

    switch (type) {
        case 'new_lead':
            headerColor = '#06c755'; // LINE Green
            headerTitle = '‚ú® ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà (New Lead)';
            altText = `‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏´‡∏°‡πà: ${data.leadName}`;
            statusColor = '#06c755';
            break;
        case 'update_status':
            headerColor = '#f97316'; // Orange
            headerTitle = 'üìù ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Update)';
            altText = `‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï: ${data.leadName}`;
            statusColor = '#f97316';
            break;
        case 'delete_lead':
            headerColor = '#ef4444'; // Red
            headerTitle = 'üóëÔ∏è ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Delete)';
            altText = `‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ${data.leadName}`;
            statusColor = '#ff334b';
            break;
        case 'birthday': // Single birthday or legacy check
            headerColor = '#ec4899'; // Pink
            headerTitle = 'üéÇ ‡∏™‡∏∏‡∏Ç‡∏™‡∏±‡∏ô‡∏ï‡πå‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î (Birthday)';
            altText = `‡∏™‡∏∏‡∏Ç‡∏™‡∏±‡∏ô‡∏ï‡πå‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤`;
            break;
        case 'test':
            headerColor = '#8b5cf6'; // Violet
            headerTitle = 'üîî ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö (Test)';
            altText = `‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô`;
            break;
        case 'idle_leads':
            headerColor = '#dc2626'; // Red darker
            headerTitle = '‚ö†Ô∏è Lead ‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡∏Å‡∏≥‡∏´‡∏ô‡∏î';
            altText = `‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô Lead ‡∏Ñ‡πâ‡∏≤‡∏á`;
            break;
        case 'reassign_leads':
            headerColor = '#2563eb'; // Blue
            headerTitle = 'üîÑ ‡πÇ‡∏≠‡∏ô‡∏¢‡πâ‡∏≤‡∏¢ Lead (24‡∏ä‡∏°.)';
            altText = `‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡∏á‡∏≤‡∏ô`;
            break;
        case 'followup_reminder':
            headerColor = '#9333ea'; // Purple
            headerTitle = 'üìÖ ‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ú‡∏•‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ';
            altText = `‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô`;
            break;
        case 'birthday_report':
            headerColor = '#db2777'; // Pink Darker
            headerTitle = 'üç∞ ‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤';
            altText = `‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤`;
            break;
    }

    let bodyContents: any[] = [];
    const now = new Date();
    const dateStr = now.toLocaleDateString('th-TH', { day: 'numeric', month: 'long', year: 'numeric' });
    const timeStr = now.toLocaleTimeString('th-TH', { hour: '2-digit', minute: '2-digit' });

    // Format received date for display
    const receivedDateFormatted = data.receivedDate 
        ? new Date(data.receivedDate).toLocaleDateString('th-TH', { day: 'numeric', month: 'long', year: 'numeric'}) 
        : '-';

    const createDetailRow = (label: string, value: string, valueColor: string = "#333333") => ({
        type: "box",
        layout: "baseline",
        spacing: "sm",
        contents: [
            { type: "text", text: label, color: "#aaaaaa", size: "sm", flex: 2 },
            { type: "text", text: value, wrap: true, color: valueColor, size: "sm", flex: 5, weight: "bold" }
        ]
    });

    const createTableRow = (col1: string, col2: string, col3?: string) => ({
        type: "box",
        layout: "horizontal",
        margin: "sm",
        contents: [
            { type: "text", text: col1, size: "xs", color: "#555555", flex: 4, wrap: true },
            { type: "text", text: col2, size: "xs", color: "#888888", flex: 3, align: "center" },
            col3 ? { type: "text", text: col3, size: "xs", color: "#333333", flex: 3, align: "end", weight: "bold" } : null
        ].filter(Boolean)
    });

    if (type === 'birthday_report') {
        bodyContents = [
            { type: "text", text: `‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ${dateStr}`, size: "xs", color: "#aaaaaa", align: "center", margin: "none" }
        ];

        // Today Section
        if (data.birthdaysToday && data.birthdaysToday.length > 0) {
            bodyContents.push(
                { type: "separator", margin: "md" },
                { type: "text", text: `üéâ ‡πÄ‡∏Å‡∏¥‡∏î‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ (${data.birthdaysToday.length})`, weight: "bold", size: "sm", margin: "md", color: "#db2777" }
            );
            data.birthdaysToday.forEach(l => {
                bodyContents.push({
                    type: "box",
                    layout: "horizontal",
                    margin: "sm",
                    contents: [
                        { type: "text", text: l.name, size: "sm", color: "#333333", flex: 6, weight: "bold" },
                        { type: "text", text: l.phone, size: "sm", color: "#db2777", align: "end", flex: 4 }
                    ]
                });
            });
        }

        // Month Section
        if (data.birthdaysMonth && data.birthdaysMonth.length > 0) {
            bodyContents.push(
                { type: "separator", margin: "md" },
                { type: "text", text: `üìÖ ‡πÄ‡∏Å‡∏¥‡∏î‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ (${data.birthdaysMonth.length})`, weight: "bold", size: "sm", margin: "md", color: "#0ea5e9" }
            );
             data.birthdaysMonth.forEach(l => {
                const bday = new Date(l.birthday);
                const dayStr = bday.getDate();
                bodyContents.push({
                    type: "box",
                    layout: "horizontal",
                    margin: "sm",
                    contents: [
                        { type: "text", text: l.name, size: "xs", color: "#555555", flex: 6 },
                        { type: "text", text: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ${dayStr}`, size: "xs", color: "#aaaaaa", align: "center", flex: 2 },
                        { type: "text", text: l.phone, size: "xs", color: "#0ea5e9", align: "end", flex: 4 }
                    ]
                });
            });
        }
        
        if ((!data.birthdaysToday || data.birthdaysToday.length === 0) && (!data.birthdaysMonth || data.birthdaysMonth.length === 0)) {
             bodyContents.push( { type: "text", text: "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ß‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏î‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ô‡∏µ‡πâ", size: "sm", color: "#999999", align: "center", margin: "lg" });
        }

    } else if (type === 'idle_leads' && data.leadsList) {
        bodyContents = [
            { type: "text", text: `‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏ì ‡πÄ‡∏ß‡∏•‡∏≤ ${timeStr}`, size: "xs", color: "#aaaaaa", align: "center" },
            { type: "separator", margin: "md" },
            createTableRow("‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤", "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞", "‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡πâ‡∏≤‡∏á"),
            { type: "separator", margin: "sm" },
            ...data.leadsList.slice(0, 10).map(l => { // Limit to 10 to avoid size limit
                const diffMs = new Date().getTime() - new Date(l.created_at).getTime();
                const diffMins = Math.floor(diffMs / 60000);
                const timeText = diffMins > 60 ? `${Math.floor(diffMins/60)} ‡∏ä‡∏°.` : `${diffMins} ‡∏ô‡∏≤‡∏ó‡∏µ`;
                return createTableRow(l.name, l.status, timeText);
            }),
            data.leadsList.length > 10 ? { type: "text", text: `...‡πÅ‡∏•‡∏∞‡∏≠‡∏µ‡∏Å ${data.leadsList.length - 10} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, size: "xs", color: "#aaaaaa", align: "center", margin: "md" } : null
        ].filter(Boolean);

    } else if (type === 'reassign_leads' && data.leadsList) {
        bodyContents = [
            { type: "text", text: "‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÇ‡∏≠‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥", weight: "bold", size: "sm", align: "center" },
            { type: "separator", margin: "md" },
             createTableRow("‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤", "‡πÄ‡∏ã‡∏•‡∏•‡πå‡πÄ‡∏î‡∏¥‡∏°", "‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"),
             { type: "separator", margin: "sm" },
            ...data.leadsList.slice(0, 10).map(l => createTableRow(l.name, l.profiles?.full_name?.split(' ')[0] || '-', "‡πÇ‡∏≠‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß")),
             data.leadsList.length > 10 ? { type: "text", text: `...‡πÅ‡∏•‡∏∞‡∏≠‡∏µ‡∏Å ${data.leadsList.length - 10} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`, size: "xs", color: "#aaaaaa", align: "center", margin: "md" } : null
        ].filter(Boolean);

    } else if (type === 'followup_reminder' && data.followUps) {
        bodyContents = [
             { type: "text", text: `‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ${dateStr}`, weight: "bold", size: "sm", align: "center" },
             { type: "separator", margin: "md" },
             ...data.followUps.slice(0, 10).map(e => ({
                type: "box",
                layout: "vertical",
                margin: "sm",
                contents: [
                    { type: "text", text: `üïí ${new Date(e.start_time).toLocaleTimeString('th-TH', {hour:'2-digit', minute:'2-digit'})} - ${e.title}`, size: "sm", weight: "bold", color: "#333333" },
                    { type: "text", text: `‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤: ${e.leads?.name || '-'}`, size: "xs", color: "#666666", margin: "xs" }
                ]
             })),
             data.followUps.length === 0 ? { type: "text", text: "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ", size: "sm", color: "#999999", align: "center", margin: "lg" } : null
        ].filter(Boolean);

    } else {
        // Default Single Item Layout (New Lead, Update, Delete, Test)
        bodyContents = [
            {
                type: "box",
                layout: "vertical",
                contents: [
                    { type: "text", text: dateStr, weight: "bold", color: headerColor, size: "sm" },
                    { type: "text", text: timeStr + " ‡∏ô.", size: "3xl", weight: "bold", color: "#333333", margin: "xs" }
                ]
            },
            { type: "separator", margin: "lg" },
            {
                type: "box",
                layout: "vertical",
                margin: "lg",
                spacing: "md",
                contents: [
                    data.receivedDate ? createDetailRow("‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡∏á‡∏à‡∏≠‡∏á", receivedDateFormatted) : null,
                    data.salesName ? createDetailRow("‡∏ù‡πà‡∏≤‡∏¢‡∏Ç‡∏≤‡∏¢", data.salesName) : null,
                    data.leadName ? createDetailRow("‡∏ä‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤", data.leadName) : null,
                    data.program ? createDetailRow("‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°", data.program) : null,
                    data.phone ? createDetailRow("‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£", data.phone, "#1e40af") : null,
                    
                    (type === 'update_status' || type === 'new_lead' || type === 'test') ? 
                        createDetailRow("‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞", data.status || "‡πÉ‡∏´‡∏°‡πà", statusColor) : null,

                    data.address ? createDetailRow("‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà", data.address) : null,
                    data.notes ? createDetailRow("‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏", data.notes) : null,

                     type === 'delete_lead' ? 
                        { type: "text", text: "‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß", margin: "xl", size: "xs", color: "#ef4444", align: "center" } : null
                ].filter(Boolean)
            }
        ];
    }

    const flexMessage = {
        type: "bubble",
        size: "giga",
        header: {
            type: "box",
            layout: "vertical",
            contents: [
                { type: "text", text: headerTitle, weight: "bold", color: "#FFFFFF", size: "lg" }
            ],
            backgroundColor: headerColor,
            paddingAll: "lg"
        },
        body: {
            type: "box",
            layout: "vertical",
            contents: bodyContents,
            paddingAll: "lg"
        },
        footer: {
            type: "box",
            layout: "vertical",
            contents: [
                { type: "button", action: { type: "uri", label: "‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô", uri: APP_URL }, style: "primary", color: headerColor, height: "sm" }
            ],
            paddingAll: "lg"
        }
    };

    const body = {
        to: LINE_TARGET_ID,
        messages: [
            {
                type: "flex",
                altText: altText,
                contents: flexMessage
            }
        ]
    };

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${LINE_CHANNEL_ACCESS_TOKEN}`
            },
            body: JSON.stringify(body)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`LINE API Error: ${response.status} - ${errorText}`);
        }
        console.log(`Line Notification Sent (${type})`);
    } catch (error) {
        console.error("Failed to send Line Notification", error);
    }
};

export const runConnectionTest = async (onProgress: (result: ConnectionTestResult) => void) => {
    const delay = (ms: number) => new Promise(res => setTimeout(res, ms));

    const { data: { user } } = await supabase.auth.getUser();
    const isAuthenticated = !!user;
    const userId = user?.id;

    const tests = [
        {
            name: "1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Supabase",
            requiresAuth: false,
            action: async () => ({
                success: true,
                details: "‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Supabase ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (URL ‡πÅ‡∏•‡∏∞ Key ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)",
            })
        },
        ...['profiles', 'leads', 'calendar_events', 'lead_activities', 'programs'].map((table, i) => ({
            name: `${i + 2}. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á '${table}'`,
            requiresAuth: false,
            action: async () => {
                const { error } = await supabase.from(table).select('id', { count: 'exact', head: true });
                let fix = undefined;
                if (error && table === 'programs') {
                    fix = SQL_CREATE_PROGRAMS;
                } else if (error) {
                     fix = `‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡∏≤‡∏£‡∏≤‡∏á '${table}' ‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏ô Supabase Public Schema ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß`;
                }

                return {
                    success: !error,
                    details: error ? `‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á '${table}' ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏≠‡πà‡∏≤‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô` : `‡∏û‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á '${table}'`,
                    fix: fix
                };
            }
        })),
        {
            name: "7. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô (Admin)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                return { 
                    success: true, 
                    details: "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á: ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏à‡∏≠ Error ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ SQL ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç", 
                    fix: SQL_UPDATE_USER_PASSWORD_FIX 
                };
            }
        },
        {
            name: "8. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏ï‡∏≤‡∏£‡∏≤‡∏á 'leads' (CRUD)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                return { success: true, details: "‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå Admin ‡πÅ‡∏•‡∏∞ Sales)", fix: RLS_LEADS_FIX };
            }
        },
        {
            name: "9. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏ï‡∏≤‡∏£‡∏≤‡∏á 'profiles' (Update Self)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                try {
                    const { data: profile, error: fetchError } = await supabase.from('profiles').select('full_name').eq('id', currentUserId!).single();
                    if (fetchError) throw new Error(`Fetch profile failed: ${fetchError.message}`);
                    
                    const { error: updateError } = await supabase.from('profiles').update({ full_name: profile.full_name }).eq('id', currentUserId!);
                    if (updateError) throw new Error(`Update failed: ${updateError.message}`);

                    return { success: true, details: "‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå ‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" };
                } catch (e: any) {
                    return { success: false, details: `‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ${e.message}`, fix: RLS_PROFILES_FIX };
                }
            }
        },
        {
            name: "10. ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏ï‡∏≤‡∏£‡∏≤‡∏á 'calendar_events' (CRUD)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                try {
                    const testEvent = { title: 'RLS Test Event', start_time: new Date().toISOString(), end_time: new Date().toISOString(), salesperson_id: currentUserId! };
                    const { data, error: insertError } = await supabase.from('calendar_events').insert(testEvent).select();
                    if (insertError) throw new Error(`Insert failed: ${insertError.message}`);

                    const newEventId = data[0].id;
                    const { error: updateError } = await supabase.from('calendar_events').update({ title: 'Test Update' }).eq('id', newEventId);
                    if (updateError) throw new Error(`Update failed: ${updateError.message}`);

                    const { error: deleteError } = await supabase.from('calendar_events').delete().eq('id', newEventId);
                    if (deleteError) throw new Error(`Delete failed: ${deleteError.message}`);

                    return { success: true, details: "‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå ‡∏≠‡πà‡∏≤‡∏ô, ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô, ‡∏•‡∏ö ‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á 'calendar_events' ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" };
                } catch (e: any) {
                    return { success: false, details: `‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ${e.message}`, fix: RLS_CALENDAR_FIX };
                }
            }
        },
         {
            name: "11. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ (Admin)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                 return { 
                    success: true, 
                    details: "‡∏´‡∏≤‡∏Å‡∏û‡∏ö Error 'provider_id' ‡πÉ‡∏´‡πâ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å SQL ‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÑ‡∏õ‡∏£‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô Supabase", 
                    fix: SQL_ADMIN_CREATE_USER 
                };
            }
        }
    ];

     onProgress({
        test: 'Authentication Check',
        status: isAuthenticated ? 'success' : 'info',
        details: isAuthenticated ? `‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏∞‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: ${user.email}` : '‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö ‡∏à‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (RLS)',
    });
    await delay(300);

    for (const test of tests) {
        if (test.requiresAuth && !isAuthenticated) {
            onProgress({
                test: test.name,
                status: 'info',
                details: '‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö RLS ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö',
            });
            continue;
        }

        onProgress({ test: test.name, status: 'pending', details: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£...' });
        await delay(300);
        const result = await test.action(userId);
        onProgress({
            test: test.name,
            status: result.success ? 'success' : 'failure',
            details: result.details,
            fix: (result as any).fix
        });
        if (!result.success && test.name.includes('‡∏ï‡∏≤‡∏£‡∏≤‡∏á')) break;
    }
};