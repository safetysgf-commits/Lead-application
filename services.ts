
import { LeadStatus, ConnectionTestResult, Database, Salesperson, Lead, LeadActivity, Role, Program, SalespersonWithStats } from './types.ts';
import { supabase } from './supabaseClient.ts';
import jsPDF from 'jspdf';
import 'jspdf-autotable';

type LeadInsert = Database['public']['Tables']['leads']['Insert'];
type LeadUpdate = Database['public']['Tables']['leads']['Update'];
type SalespersonInsert = Database['public']['Tables']['profiles']['Insert'];
type SalespersonUpdate = Database['public']['Tables']['profiles']['Update'];

// --- Constants ---
export const statusColors: { [key in LeadStatus]: string } = {
    [LeadStatus.New]: 'bg-blue-500',
    [LeadStatus.Uncalled]: 'bg-orange-500',
    [LeadStatus.Contacted]: 'bg-yellow-500',
    [LeadStatus.FollowUp]: 'bg-purple-500',
    [LeadStatus.Won]: 'bg-green-500',
    [LeadStatus.Lost]: 'bg-red-500',
};
export const leadStatuses = Object.values(LeadStatus);

// --- LINE NOTIFICATION CONFIG ---
const LINE_CHANNEL_ACCESS_TOKEN = 'P3MUI6dxMEaFKR8LYT0GbSZBcbV3bjvOTWA/tgTistte1TOXvagwyf6XidI/ZOy3NwIGaEXIO7xbzIxESiKXUdI39CBXH7GjTM4xlVk0x0DpZYVml3W75mFF05PUWvdJ8EnCEsDY87ihcLBxHf876QdB04t89/1O/w1cDnyilFU=';
const LINE_TARGET_ID = 'Cfe28bbc3dacaaf3d7981625b99f80c7d'; // Group ID
const APP_URL = 'https://lead-application-theta.vercel.app/';

// --- SQL SCRIPTS (Exported for UI use) ---

export const SQL_ONE_CLICK_SETUP = `
-- 1. Enable pgcrypto
create extension if not exists "pgcrypto";

-- 2. Create Tables
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  full_name text,
  role text default 'sales',
  avatar_url text,
  status text default 'online',
  last_active timestamp with time zone default now(),
  updated_at timestamp with time zone,
  created_at timestamp with time zone default now()
);
alter table public.profiles enable row level security;

-- Add Role Constraint if not exists (Best Practice)
ALTER TABLE public.profiles DROP CONSTRAINT IF EXISTS valid_role;
ALTER TABLE public.profiles ADD CONSTRAINT valid_role CHECK (role IN ('admin', 'sales', 'after_care'));

create table if not exists public.leads (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,
  name text not null,
  phone text not null,
  program text,
  status text default 'à¹ƒà¸«à¸¡à¹ˆ',
  assigned_to uuid references public.profiles(id),
  notes text,
  received_date timestamp with time zone default now(),
  birthday timestamp with time zone,
  address text,
  value numeric,
  last_update_date timestamp with time zone,
  source text
);
alter table public.leads enable row level security;

create table if not exists public.calendar_events (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,
  title text not null,
  start_time timestamp with time zone not null,
  end_time timestamp with time zone not null,
  salesperson_id uuid references public.profiles(id) not null,
  lead_id bigint references public.leads(id)
);
alter table public.calendar_events enable row level security;

create table if not exists public.lead_activities (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now() not null,
  lead_id bigint references public.leads(id) not null,
  activity_description text not null,
  user_id uuid references public.profiles(id),
  user_name text
);
alter table public.lead_activities enable row level security;

create table if not exists public.programs (
  id bigint generated by default as identity primary key,
  name text not null,
  created_at timestamp with time zone default now() not null
);
alter table public.programs enable row level security;

-- 3. Create Function admin_create_user
DROP FUNCTION IF EXISTS admin_create_user(text, text, text, text);
CREATE OR REPLACE FUNCTION admin_create_user(email_input text, password_input text, full_name_input text, role_input text)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_user_id uuid;
BEGIN
  IF EXISTS (SELECT 1 FROM auth.users WHERE email = email_input) THEN
     SELECT id INTO new_user_id FROM auth.users WHERE email = email_input;
  ELSE
      insert into auth.users (
        instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, raw_app_meta_data, raw_user_meta_data, created_at, updated_at
      )
      values (
        '00000000-0000-0000-0000-000000000000', gen_random_uuid(), 'authenticated', 'authenticated', email_input, crypt(password_input, gen_salt('bf')), now(), '{"provider":"email","providers":["email"]}', json_build_object('full_name', full_name_input, 'role', role_input), now(), now()
      )
      returning id into new_user_id;

      insert into auth.identities (id, user_id, identity_data, provider, provider_id, last_sign_in_at, created_at, updated_at)
      values (gen_random_uuid(), new_user_id, json_build_object('sub', new_user_id, 'email', email_input, 'email_verified', true, 'phone_verified', false), 'email', new_user_id::text, now(), now(), now());
  END IF;

  insert into public.profiles (id, full_name, role, email, status, last_active)
  values (new_user_id, full_name_input, role_input, email_input, 'online', now())
  on conflict (id) do update
  set full_name = excluded.full_name, role = excluded.role, email = excluded.email;

  RETURN new_user_id;
END;
$$;

-- 4. Create Default Admin
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'admin@admin') THEN
        PERFORM admin_create_user('admin@admin', 'admin123', 'Super Admin', 'admin');
    END IF;
END $$;
`;

export const SQL_CREATE_ALL_TABLES = SQL_ONE_CLICK_SETUP; // Alias for backward compatibility

export const SQL_FIX_ROLE_CONSTRAINT = `
-- Drop the existing constraint if it exists (fixes 'valid_role' violation)
ALTER TABLE public.profiles DROP CONSTRAINT IF EXISTS valid_role;

-- Add the correct constraint allowing 'admin', 'sales', and 'after_care'
ALTER TABLE public.profiles ADD CONSTRAINT valid_role 
CHECK (role IN ('admin', 'sales', 'after_care'));
`;

export const SQL_ADD_LAST_ACTIVE = `
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS last_active timestamp with time zone DEFAULT now();
`;

export const RLS_LEADS_FIX = `-- This script resets RLS for the 'leads' table.
DROP POLICY IF EXISTS "Admins can manage all leads." ON public.leads;
DROP POLICY IF EXISTS "Admins can insert new leads." ON public.leads;
DROP POLICY IF EXISTS "Sales can view their own assigned leads." ON public.leads;
DROP POLICY IF EXISTS "Sales can update their own assigned leads." ON public.leads;
DROP POLICY IF EXISTS "Sales can delete their own assigned leads." ON public.leads;

CREATE POLICY "Admins can manage all leads." ON public.leads FOR ALL USING (get_my_role() = 'admin');
CREATE POLICY "Admins can insert new leads." ON public.leads FOR INSERT WITH CHECK (get_my_role() = 'admin');
CREATE POLICY "Sales can view their own assigned leads." ON public.leads FOR SELECT USING (assigned_to = auth.uid());
CREATE POLICY "Sales can update their own assigned leads." ON public.leads FOR UPDATE USING (assigned_to = auth.uid());
CREATE POLICY "Sales can delete their own assigned leads." ON public.leads FOR DELETE USING (assigned_to = auth.uid());`;

export const RLS_PROFILES_FIX = `-- This script resets RLS for the 'profiles' table.
DROP POLICY IF EXISTS "Admins can manage all profiles." ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;

CREATE POLICY "Admins can manage all profiles." ON public.profiles FOR ALL USING (get_my_role() = 'admin');
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);`;

export const RLS_CALENDAR_FIX = `-- This script resets RLS for the 'calendar_events' table.
DROP POLICY IF EXISTS "Admins can manage all calendar events." ON public.calendar_events;
DROP POLICY IF EXISTS "Sales can manage their own calendar events." ON public.calendar_events;

CREATE POLICY "Admins can manage all calendar events." ON public.calendar_events FOR ALL USING (get_my_role() = 'admin');
CREATE POLICY "Sales can manage their own calendar events." ON public.calendar_events FOR ALL USING (salesperson_id = auth.uid()) WITH CHECK (salesperson_id = auth.uid());`;

export const SQL_CREATE_PROGRAMS = `-- Create the programs table and policies
CREATE TABLE IF NOT EXISTS public.programs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

ALTER TABLE public.programs ENABLE ROW LEVEL SECURITY;

-- Policies
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'programs' AND policyname = 'Everyone can read programs') THEN
        CREATE POLICY "Everyone can read programs" ON public.programs FOR SELECT USING (true);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'programs' AND policyname = 'Admins can manage programs') THEN
        CREATE POLICY "Admins can manage programs" ON public.programs FOR ALL USING (get_my_role() = 'admin');
    END IF;
END $$;`;

export const SQL_UPDATE_USER_PASSWORD_FIX = `-- à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸š Admin à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¹ƒà¸«à¹‰ User à¸­à¸·à¹ˆà¸™
create extension if not exists "pgcrypto";

create or replace function update_user_password(user_id uuid, new_password text)
returns void
language plpgsql
security definer
as $$
begin
  update auth.users
  set encrypted_password = crypt(new_password, gen_salt('bf'))
  where id = user_id;
end;
$$;`;

export const SQL_ADMIN_CREATE_USER = `-- Enable pgcrypto if not already enabled
create extension if not exists "pgcrypto";

-- Drop existing function to ensure clean update of parameters/logic
DROP FUNCTION IF EXISTS admin_create_user(text, text, text, text);

-- Function to create user
create or replace function admin_create_user(email_input text, password_input text, full_name_input text, role_input text)
returns uuid
language plpgsql
security definer
as $$
declare
  new_user_id uuid;
begin
  -- Check if user exists
  if exists (select 1 from auth.users where email = email_input) then
    raise exception 'User with this email already exists';
  end if;

  -- Create user in auth.users
  insert into auth.users (
    instance_id,
    id,
    aud,
    role,
    email,
    encrypted_password,
    email_confirmed_at,
    raw_app_meta_data,
    raw_user_meta_data,
    created_at,
    updated_at
  )
  values (
    '00000000-0000-0000-0000-000000000000',
    gen_random_uuid(),
    'authenticated',
    'authenticated',
    email_input,
    crypt(password_input, gen_salt('bf')),
    now(),
    '{"provider":"email","providers":["email"]}',
    json_build_object('full_name', full_name_input, 'role', role_input),
    now(),
    now()
  )
  returning id into new_user_id;

  -- Create identity (Required for login to work properly)
  insert into auth.identities (
    id,
    user_id,
    identity_data,
    provider,
    provider_id,
    last_sign_in_at,
    created_at,
    updated_at
  )
  values (
    gen_random_uuid(),
    new_user_id,
    json_build_object('sub', new_user_id, 'email', email_input, 'email_verified', true, 'phone_verified', false),
    'email',
    new_user_id::text,
    now(),
    now(),
    now()
  );

  -- Ensure profile exists (in case trigger didn't catch it or for robustness)
  insert into public.profiles (id, full_name, role, email)
  values (new_user_id, full_name_input, role_input, email_input)
  on conflict (id) do update
  set full_name = excluded.full_name,
      role = excluded.role,
      email = excluded.email;

  return new_user_id;
end;
$$;`;

export const SQL_CREATE_DEFAULT_ADMIN = `-- Create default admin user (admin@admin / admin123)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'admin@admin') THEN
        PERFORM admin_create_user('admin@admin', 'admin123', 'Super Admin', 'admin');
    END IF;
END $$;
`;

// --- Data Services ---

// Helper function to check online status (5 min threshold)
export const isUserOnline = (user: { status?: string | null, last_active?: string | null }): boolean => {
    if (user.status === 'offline') return false;
    if (!user.last_active) return false;
    
    const lastActive = new Date(user.last_active);
    const now = new Date();
    const diffMs = now.getTime() - lastActive.getTime();
    const diffMins = diffMs / (1000 * 60);
    
    // User is online only if status is 'online' AND active within last 5 mins
    return diffMins < 5;
};

export const getLeads = async (role: 'admin' | 'sales', userId?: string) => {
    let query = supabase
      .from('leads')
      .select(`
        *,
        profiles (
            full_name
        )
      `)
      .order('received_date', { ascending: false });

    if (role === 'sales' && userId) {
        query = query.eq('assigned_to', userId);
    }
    
    const { data, error } = await query;
    if (error) throw error;
    return data;
};

export const getUnreadLeadsCount = async (userId: string) => {
    const { count, error } = await supabase
        .from('leads')
        .select('*', { count: 'exact', head: true })
        .eq('assigned_to', userId)
        .in('status', ['à¹ƒà¸«à¸¡à¹ˆ', 'à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹‚à¸—à¸£']);
    if (error) {
        console.error("Error fetching unread leads count:", error);
        return 0;
    }
    return count ?? 0;
};

export const createLead = async (leadData: LeadInsert) => {
    const { data, error } = await supabase.from('leads').insert(leadData).select().single();
    if (error) throw error;
    return data;
};

export const updateLead = async (id: number, leadData: LeadUpdate) => {
    const { data, error } = await supabase.from('leads').update(leadData).eq('id', id).select().single();
    if (error) throw error;
    return data;
};

export const deleteLead = async (id: number) => {
    const { error } = await supabase.from('leads').delete().eq('id', id);
    if (error) throw error;
};

export const getSalesTeam = async (): Promise<Salesperson[]> => {
    const { data, error } = await supabase.from('profiles').select('*').order('full_name');
    if (error) throw error;
    return data;
};

export const adminCreateUser = async (userData: { fullName: string, email: string, password: string, role: Role }) => {
    const { error } = await supabase.rpc('admin_create_user', {
        email_input: userData.email,
        password_input: userData.password,
        full_name_input: userData.fullName,
        role_input: userData.role,
    });
    if (error) throw error;
};

export const updateSalesperson = async (id: string, salespersonData: SalespersonUpdate) => {
     const { error } = await supabase.from('profiles').update(salespersonData).eq('id', id);
    if (error) throw error;
};

export const updateUserStatus = async (userId: string, status: 'online' | 'offline') => {
    const { error } = await supabase.from('profiles').update({ 
        status, 
        last_active: new Date().toISOString() 
    }).eq('id', userId);
    if (error) throw error;
};

export const updateUserPassword = async (userId: string, newPassword: string) => {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user && user.id === userId) {
        const { error } = await supabase.auth.updateUser({ password: newPassword });
        if (error) throw error;
        return;
    }

    const { error } = await supabase.rpc('update_user_password', {
        user_id: userId,
        new_password: newPassword
    });
    if (error) throw error;
};


export const deleteSalesperson = async (id: string) => {
     const { error } = await supabase.from('profiles').delete().eq('id', id);
    if (error) throw error;
};

export const getCalendarEvents = async (role: 'admin' | 'sales', userId: string) => {
    // 1. Fetch Manual Appointments
    let query = supabase.from('calendar_events').select('*, leads(name)');
     if (role === 'sales') {
        query = query.eq('salesperson_id', userId);
    }
    const { data: appointments, error } = await query;
    if (error) throw error;

    // 2. Fetch Leads for Bookings and Birthdays
    let leadsQuery = supabase.from('leads').select('id, name, received_date, birthday, program, assigned_to');
    if (role === 'sales') {
        leadsQuery = leadsQuery.eq('assigned_to', userId);
    }
    const { data: leads, error: leadsError } = await leadsQuery;
    if (leadsError) throw leadsError;

    const events = [...(appointments || [])];

    // 3. Map Leads to Events
    leads?.forEach((lead) => {
        // Booking Event (à¸§à¸±à¸™à¸—à¸µà¹ˆà¸ˆà¸­à¸‡)
        if (lead.received_date) {
            events.push({
                id: -lead.id, // Negative ID to distinguish
                title: `${lead.name} (${lead.program || 'N/A'})`,
                start_time: lead.received_date,
                end_time: lead.received_date,
                salesperson_id: lead.assigned_to,
                lead_id: lead.id,
                leads: { name: lead.name },
                type: 'booking' // Custom type
            } as any);
        }

        // Birthday Event (Current Year)
        if (lead.birthday) {
             const bday = new Date(lead.birthday);
             const today = new Date();
             const currentYearBday = new Date(today.getFullYear(), bday.getMonth(), bday.getDate());
             
             // If birthday passed this year but we are viewing next year? 
             // Simplification: Just show for current year.
             
             events.push({
                id: -(lead.id + 1000000), // Distinct ID
                title: `ðŸŽ‚ HBD ${lead.name}`,
                start_time: currentYearBday.toISOString(),
                end_time: currentYearBday.toISOString(),
                salesperson_id: lead.assigned_to,
                lead_id: lead.id,
                leads: { name: lead.name },
                type: 'birthday' // Custom type
            } as any);
        }
    });

    return events;
};

export const createFollowUpAppointments = async (leadId: number, salespersonId: string, serviceDate: string, leadName: string) => {
    const date = new Date(serviceDate);
    const followUps = [
        { label: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥ 1 à¸§à¸±à¸™', offsetMonth: 0, offsetDay: 1 },
        { label: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥ 1 à¹€à¸”à¸·à¸­à¸™', offsetMonth: 1, offsetDay: 0 },
        { label: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥ 3 à¹€à¸”à¸·à¸­à¸™', offsetMonth: 3, offsetDay: 0 },
        { label: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥ 6 à¹€à¸”à¸·à¸­à¸™', offsetMonth: 6, offsetDay: 0 },
        { label: 'à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥ 1 à¸›à¸µ', offsetMonth: 12, offsetDay: 0 },
    ];

    const events = followUps.map(item => {
        const d = new Date(date);
        d.setMonth(d.getMonth() + item.offsetMonth);
        d.setDate(d.getDate() + item.offsetDay);
        
        return {
            title: `${item.label}`,
            start_time: d.toISOString(),
            end_time: new Date(d.getTime() + 60 * 60 * 1000).toISOString(),
            salesperson_id: salespersonId,
            lead_id: leadId
        };
    });

    const { error } = await supabase.from('calendar_events').insert(events);
    if (error) throw error;
};

export const getDashboardStats = async (role: 'admin' | 'sales', userId?: string, dateRange?: { start: string, end: string }) => {
    if(role === 'admin') {
        let leadsQuery = supabase.from('leads').select('value, status, created_at');
        if (dateRange) {
            leadsQuery = leadsQuery.gte('created_at', dateRange.start).lte('created_at', dateRange.end);
        }
        const { data: leads, error: leadsError } = await leadsQuery;
        if (leadsError) throw leadsError;

        const { count: teamSize, error: teamError } = await supabase.from('profiles').select('*', { count: 'exact', head: true });
        if (teamError) throw teamError;
        
        const wonLeads = leads.filter(l => l.status === LeadStatus.Won);
        
        return {
            totalLeads: leads.length,
            newLeads: leads.filter(l => new Date(l.created_at) >= new Date(new Date().toDateString())).length,
            totalValue: wonLeads.reduce((sum, lead) => sum + (lead.value || 0), 0),
            teamSize: teamSize ?? 0,
            conversionRate: leads.length > 0 ? Math.round((wonLeads.length / leads.length) * 100) : 0,
        }
    } else {
        const { data: salesLeads, error } = await supabase.from('leads').select('status, value').eq('assigned_to', userId!);
        if (error) throw error;

        const wonLeads = salesLeads.filter(l => l.status === LeadStatus.Won);
        const monthlySales = wonLeads.reduce((sum, lead) => sum + (lead.value || 0), 0);

        return {
            totalLeads: salesLeads.length,
            uncalledLeads: salesLeads.filter(l => l.status === LeadStatus.Uncalled).length,
            wonLeads: wonLeads.length,
            monthlySales: monthlySales,
            conversionRate: salesLeads.length > 0 ? Math.round((wonLeads.length / salesLeads.length) * 100) : 0
        }
    }
};

export const getSalesPerformance = async (dateRange?: { start: string, end: string }) => {
    const { data: profiles, error: profileError } = await supabase.from('profiles').select('id, full_name').eq('role', 'sales');
    if (profileError) throw profileError;
    
    let leadsQuery = supabase.from('leads').select('assigned_to, value, status, created_at').eq('status', 'à¸ªà¸³à¹€à¸£à¹‡à¸ˆ');
    if (dateRange) {
        leadsQuery = leadsQuery.gte('created_at', dateRange.start).lte('created_at', dateRange.end);
    }
    const { data: leads, error: leadError } = await leadsQuery;
    if (leadError) throw leadError;

    return profiles.map(sales => {
        const salesLeads = leads.filter(lead => lead.assigned_to === sales.id);
        return {
            name: (sales.full_name || 'N/A').split(' ')[0],
            sales: salesLeads.reduce((sum, lead) => sum + (lead.value || 0), 0),
            leads: salesLeads.length
        }
    });
};

export const getSalesTeamPerformance = async (): Promise<SalespersonWithStats[]> => {
    const { data: profiles, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .in('role', ['sales', 'after_care']);
    if (profileError) throw profileError;

    const { data: leads, error: leadError } = await supabase
        .from('leads')
        .select('assigned_to, value, status');
    if (leadError) throw leadError;

    const performanceData = profiles.map(salesperson => {
        const salespersonLeads = leads.filter(lead => lead.assigned_to === salesperson.id);
        
        const wonLeads = salespersonLeads.filter(l => l.status === LeadStatus.Won);
        const lostLeads = salespersonLeads.filter(l => l.status === LeadStatus.Lost);
        const uncalledLeads = salespersonLeads.filter(l => l.status === LeadStatus.Uncalled);
        
        const totalSales = wonLeads.reduce((sum, lead) => sum + (lead.value || 0), 0);
        const totalLeads = salespersonLeads.length;
        
        const conversionRate = totalLeads > 0 ? Math.round((wonLeads.length / totalLeads) * 100) : 0;

        return {
            ...salesperson,
            totalSales: totalSales,
            totalLeads: totalLeads,
            uncalledLeads: uncalledLeads.length,
            wonLeads: wonLeads.length,
            lostLeads: lostLeads.length,
            conversionRate: conversionRate
        };
    });

    return performanceData.sort((a, b) => b.totalSales - a.totalSales);
};

export const getConversionRates = async (salespersonId?: string, dateRange?: { start: string, end: string }) => {
    let query = supabase.from('leads').select('status, created_at');
    if (salespersonId) {
        query = query.eq('assigned_to', salespersonId);
    }
    if (dateRange) {
        query = query.gte('created_at', dateRange.start).lte('created_at', dateRange.end);
    }
    const { data: leads, error } = await query;
    if (error) throw error;
    
    const won = leads.filter(l => l.status === LeadStatus.Won).length;
    const lost = leads.filter(l => l.status === LeadStatus.Lost).length;
    const inProgress = leads.length - won - lost;
    return [
        { name: 'à¸ªà¸³à¹€à¸£à¹‡à¸ˆ', value: won },
        { name: 'à¸¢à¸à¹€à¸¥à¸´à¸', value: lost },
        { name: 'à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£à¸­à¸¢à¸¹à¹ˆ', value: inProgress },
    ];
};

export const getSalesTrend = async (dateRange?: { start: string, end: string }) => {
    return [
        { name: 'à¸¡.à¸„.', sales: 120000 },
        { name: 'à¸.à¸ž.', sales: 150000 },
        { name: 'à¸¡à¸µ.à¸„.', sales: 130000 },
        { name: 'à¹€à¸¡.à¸¢.', sales: 180000 },
        { name: 'à¸ž.à¸„.', sales: 210000 },
        { name: 'à¸¡à¸´.à¸¢.', sales: 190000 },
    ];
};

export const getBirthdays = async (salespersonId?: string) => {
    let query = supabase.from('leads').select('id, name, birthday, phone');
    if (salespersonId) {
        query = query.eq('assigned_to', salespersonId);
    }
    const { data, error } = await query;
    if (error) throw error;

    const relevantLeads = data.filter(l => l.birthday);

    const todayDate = new Date();
    const todayLeads = relevantLeads.filter(l => {
        const bday = new Date(l.birthday!);
        return bday.getUTCDate() === todayDate.getUTCDate() && bday.getUTCMonth() === todayDate.getUTCMonth();
    });
    const thisMonthLeads = relevantLeads.filter(l => {
        const bday = new Date(l.birthday!);
        return bday.getUTCMonth() === todayDate.getUTCMonth();
    });
    return { today: todayLeads, thisMonth: thisMonthLeads };
}

// --- Program Services ---
export const getPrograms = async (): Promise<Program[]> => {
    const { data, error } = await supabase.from('programs').select('*').order('name');
    if (error) throw error;
    return data;
};

export const createProgram = async (name: string) => {
    const { error } = await supabase.from('programs').insert({ name });
    if (error) throw error;
};

export const deleteProgram = async (id: number) => {
    const { error } = await supabase.from('programs').delete().eq('id', id);
    if (error) throw error;
};

// --- Lead Activity Services ---
export const getLeadActivities = async (leadId: number): Promise<LeadActivity[]> => {
    const { data, error } = await supabase
        .from('lead_activities')
        .select('*')
        .eq('lead_id', leadId)
        .order('created_at', { ascending: false });
    if (error) throw error;
    return data;
};

export const createLeadActivity = async (leadId: number, description: string) => {
    const { data: { user } } = await supabase.auth.getUser();
    const { data: profile } = await supabase.from('profiles').select('full_name').eq('id', user?.id).single();
    
    const activityData = {
        lead_id: leadId,
        activity_description: description,
        user_id: user?.id,
        user_name: profile?.full_name || user?.email,
    };
    const { error } = await supabase.from('lead_activities').insert(activityData);
    if (error) throw error;
};

// --- Export Services ---

export const exportToCSV = (data: any[], filename?: string) => {
    if (!data || !data.length) return;
    
    // Define headers manually to ensure order and specific fields
    const headers = ['ID', 'Date', 'Name', 'Phone', 'Program', 'Status', 'Value', 'Assigned To', 'Address', 'Notes'];
    
    const csvRows = [headers.join(',')];

    for (const row of data) {
        const values = [
            row.id,
            row.received_date ? new Date(row.received_date).toLocaleDateString('th-TH') : '',
            `"${(row.name || '').replace(/"/g, '""')}"`,
            `"${(row.phone || '').replace(/"/g, '""')}"`,
            `"${(row.program || '').replace(/"/g, '""')}"`,
            row.status,
            row.value || 0,
            `"${(row.profiles?.full_name || row.assigned_to || '').replace(/"/g, '""')}"`,
            `"${(row.address || '').replace(/"/g, '""')}"`,
            `"${(row.notes || '').replace(/"/g, '""')}"`,
        ];
        csvRows.push(values.join(','));
    }

    const blob = new Blob(["\uFEFF" + csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `export_${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

export const exportToPDF = (data: any[], filename?: string) => {
    const doc = new jsPDF();
    
    // Note: Thai characters might not render correctly without a custom font.
    // Using standard font for compatibility.
    
    doc.setFontSize(18);
    doc.text("Leads Export", 14, 22);
    doc.setFontSize(10);
    doc.text(`Generated on: ${new Date().toLocaleDateString('th-TH')}`, 14, 28);
    
    const tableColumn = ["Date", "Name", "Phone", "Program", "Status", "Sales", "Value"];
    const tableRows: any[] = [];

    data.forEach(lead => {
        const leadData = [
            lead.received_date ? new Date(lead.received_date).toLocaleDateString('th-TH') : '',
            lead.name || '',
            lead.phone || '',
            lead.program || '',
            lead.status || '',
            lead.profiles?.full_name || '',
            (lead.value || 0).toLocaleString(),
        ];
        tableRows.push(leadData);
    });

    (doc as any).autoTable({
        head: [tableColumn],
        body: tableRows,
        startY: 35,
        styles: { fontSize: 8 }, 
        headStyles: { fillColor: [14, 165, 233] }, // Sky-500
    });
    
    doc.save(filename || `export_${new Date().toISOString().split('T')[0]}.pdf`);
};

// --- LINE Messaging API Integration ---

export type LineNotificationType = 'new_lead' | 'update_status' | 'delete_lead' | 'birthday' | 'test' | 'idle_leads' | 'reassign_leads' | 'followup_reminder' | 'birthday_report';

export interface LineNotificationData {
    leadName?: string;
    program?: string | null;
    status?: string;
    salesName?: string | null;
    phone?: string;
    receivedDate?: string;
    address?: string | null;
    notes?: string | null;
    leads?: Lead[]; // Deprecated for birthday, use specific fields below
    // New fields for complex reports
    leadsList?: any[]; // For Idle/Reassign reports
    birthdaysToday?: any[];
    birthdaysMonth?: any[];
    followUps?: any[];
}

export const sendLineNotification = async (type: LineNotificationType, data: LineNotificationData) => {
    // Use a CORS proxy to bypass browser restrictions for demo purposes.
    const lineApiUrl = 'https://api.line.me/v2/bot/message/push';
    const url = `https://corsproxy.io/?${encodeURIComponent(lineApiUrl)}`;
    
    let headerColor = '#0ea5e9'; // Default Blue
    let headerTitle = 'à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™';
    let altText = 'CRM Notification';
    let statusColor = '#666666';

    switch (type) {
        case 'new_lead':
            headerColor = '#06c755'; // LINE Green
            headerTitle = 'âœ¨ à¸¥à¸¹à¸à¸„à¹‰à¸²à¹ƒà¸«à¸¡à¹ˆ (New Lead)';
            altText = `à¸¥à¸¹à¸à¸„à¹‰à¸²à¹ƒà¸«à¸¡à¹ˆ: ${data.leadName}`;
            statusColor = '#06c755';
            break;
        case 'update_status':
            headerColor = '#f97316'; // Orange
            headerTitle = 'ðŸ“ à¸­à¸±à¸›à¹€à¸”à¸•à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (Update)';
            altText = `à¸­à¸±à¸›à¹€à¸”à¸•: ${data.leadName}`;
            statusColor = '#f97316';
            break;
        case 'delete_lead':
            headerColor = '#ef4444'; // Red
            headerTitle = 'ðŸ—‘ï¸ à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (Delete)';
            altText = `à¸¥à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥: ${data.leadName}`;
            statusColor = '#ff334b';
            break;
        case 'birthday': // Single birthday or legacy check
            headerColor = '#ec4899'; // Pink
            headerTitle = 'ðŸŽ‚ à¸ªà¸¸à¸‚à¸ªà¸±à¸™à¸•à¹Œà¸§à¸±à¸™à¹€à¸à¸´à¸” (Birthday)';
            altText = `à¸ªà¸¸à¸‚à¸ªà¸±à¸™à¸•à¹Œà¸§à¸±à¸™à¹€à¸à¸´à¸”à¸¥à¸¹à¸à¸„à¹‰à¸²`;
            break;
        case 'test':
            headerColor = '#8b5cf6'; // Violet
            headerTitle = 'ðŸ”” à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸šà¸š (Test)';
            altText = `à¸—à¸”à¸ªà¸­à¸šà¸à¸²à¸£à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™`;
            break;
        case 'idle_leads':
            headerColor = '#dc2626'; // Red darker
            headerTitle = 'âš ï¸ Lead à¸„à¹‰à¸²à¸‡à¹€à¸à¸´à¸™à¸à¸³à¸«à¸™à¸”';
            altText = `à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™ Lead à¸„à¹‰à¸²à¸‡`;
            break;
        case 'reassign_leads':
            headerColor = '#2563eb'; // Blue
            headerTitle = 'ðŸ”„ à¹‚à¸­à¸™à¸¢à¹‰à¸²à¸¢ Lead (24à¸Šà¸¡.)';
            altText = `à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™à¸à¸²à¸£à¹‚à¸­à¸™à¸¢à¹‰à¸²à¸¢à¸‡à¸²à¸™`;
            break;
        case 'followup_reminder':
            headerColor = '#9333ea'; // Purple
            headerTitle = 'ðŸ“… à¸™à¸±à¸”à¸«à¸¡à¸²à¸¢à¸•à¸´à¸”à¸•à¸²à¸¡à¸œà¸¥à¸§à¸±à¸™à¸™à¸µà¹‰';
            altText = `à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™à¸™à¸±à¸”à¸«à¸¡à¸²à¸¢à¸›à¸£à¸°à¸ˆà¸³à¸§à¸±à¸™`;
            break;
        case 'birthday_report':
            headerColor = '#db2777'; // Pink Darker
            headerTitle = 'ðŸ° à¸£à¸²à¸¢à¸‡à¸²à¸™à¸§à¸±à¸™à¹€à¸à¸´à¸”à¸¥à¸¹à¸à¸„à¹‰à¸²';
            altText = `à¸£à¸²à¸¢à¸‡à¸²à¸™à¸§à¸±à¸™à¹€à¸à¸´à¸”à¸¥à¸¹à¸à¸„à¹‰à¸²`;
            break;
    }

    let bodyContents: any[] = [];
    const now = new Date();
    const dateStr = now.toLocaleDateString('th-TH', { day: 'numeric', month: 'long', year: 'numeric' });
    const timeStr = now.toLocaleTimeString('th-TH', { hour: '2-digit', minute: '2-digit' });

    // Format received date for display
    const receivedDateFormatted = data.receivedDate 
        ? new Date(data.receivedDate).toLocaleDateString('th-TH', { day: 'numeric', month: 'long', year: 'numeric'}) 
        : '-';

    const createDetailRow = (label: string, value: string, valueColor: string = "#333333") => ({
        type: "box",
        layout: "baseline",
        spacing: "sm",
        contents: [
            { type: "text", text: label, color: "#aaaaaa", size: "sm", flex: 2 },
            { type: "text", text: value, wrap: true, color: valueColor, size: "sm", flex: 5, weight: "bold" }
        ]
    });

    const createTableRow = (col1: string, col2: string, col3?: string) => ({
        type: "box",
        layout: "horizontal",
        margin: "sm",
        contents: [
            { type: "text", text: col1, size: "xs", color: "#555555", flex: 4, wrap: true },
            { type: "text", text: col2, size: "xs", color: "#888888", flex: 3, align: "center" },
            col3 ? { type: "text", text: col3, size: "xs", color: "#333333", flex: 3, align: "end", weight: "bold" } : null
        ].filter(Boolean)
    });

    if (type === 'birthday_report') {
        bodyContents = [
            { type: "text", text: `à¸›à¸£à¸°à¸ˆà¸³à¸§à¸±à¸™à¸—à¸µà¹ˆ ${dateStr}`, size: "xs", color: "#aaaaaa", align: "center", margin: "none" }
        ];

        // Today Section
        if (data.birthdaysToday && data.birthdaysToday.length > 0) {
            bodyContents.push(
                { type: "separator", margin: "md" },
                { type: "text", text: `ðŸŽ‰ à¹€à¸à¸´à¸”à¸§à¸±à¸™à¸™à¸µà¹‰ (${data.birthdaysToday.length})`, weight: "bold", size: "sm", margin: "md", color: "#db2777" }
            );
            data.birthdaysToday.forEach(l => {
                bodyContents.push({
                    type: "box",
                    layout: "horizontal",
                    margin: "sm",
                    contents: [
                        { type: "text", text: l.name, size: "sm", color: "#333333", flex: 6, weight: "bold" },
                        { type: "text", text: l.phone, size: "sm", color: "#db2777", align: "end", flex: 4 }
                    ]
                });
            });
        }

        // Month Section
        if (data.birthdaysMonth && data.birthdaysMonth.length > 0) {
            bodyContents.push(
                { type: "separator", margin: "md" },
                { type: "text", text: `ðŸ“… à¹€à¸à¸´à¸”à¹€à¸”à¸·à¸­à¸™à¸™à¸µà¹‰ (${data.birthdaysMonth.length})`, weight: "bold", size: "sm", margin: "md", color: "#0ea5e9" }
            );
             data.birthdaysMonth.forEach(l => {
                const bday = new Date(l.birthday);
                const dayStr = bday.getDate();
                bodyContents.push({
                    type: "box",
                    layout: "horizontal",
                    margin: "sm",
                    contents: [
                        { type: "text", text: l.name, size: "xs", color: "#555555", flex: 6 },
                        { type: "text", text: `à¸§à¸±à¸™à¸—à¸µà¹ˆ ${dayStr}`, size: "xs", color: "#aaaaaa", align: "center", flex: 2 },
                        { type: "text", text: l.phone, size: "xs", color: "#0ea5e9", align: "end", flex: 4 }
                    ]
                });
            });
        }
        
        if ((!data.birthdaysToday || data.birthdaysToday.length === 0) && (!data.birthdaysMonth || data.birthdaysMonth.length === 0)) {
             bodyContents.push( { type: "text", text: "à¹„à¸¡à¹ˆà¸¡à¸µà¸£à¸²à¸¢à¸à¸²à¸£à¸§à¸±à¸™à¹€à¸à¸´à¸”à¹ƒà¸™à¸Šà¹ˆà¸§à¸‡à¸™à¸µà¹‰", size: "sm", color: "#999999", align: "center", margin: "lg" });
        }

    } else if (type === 'idle_leads' && data.leadsList) {
        bodyContents = [
            { type: "text", text: `à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ à¸“ à¹€à¸§à¸¥à¸² ${timeStr}`, size: "xs", color: "#aaaaaa", align: "center" },
            { type: "separator", margin: "md" },
            createTableRow("à¸Šà¸·à¹ˆà¸­à¸¥à¸¹à¸à¸„à¹‰à¸²", "à¸ªà¸–à¸²à¸™à¸°", "à¹€à¸§à¸¥à¸²à¸—à¸µà¹ˆà¸„à¹‰à¸²à¸‡"),
            { type: "separator", margin: "sm" },
            ...data.leadsList.slice(0, 10).map(l => { // Limit to 10 to avoid size limit
                const diffMs = new Date().getTime() - new Date(l.created_at).getTime();
                const diffMins = Math.floor(diffMs / 60000);
                const timeText = diffMins > 60 ? `${Math.floor(diffMins/60)} à¸Šà¸¡.` : `${diffMins} à¸™à¸²à¸—à¸µ`;
                return createTableRow(l.name, l.status, timeText);
            }),
            data.leadsList.length > 10 ? { type: "text", text: `...à¹à¸¥à¸°à¸­à¸µà¸ ${data.leadsList.length - 10} à¸£à¸²à¸¢à¸à¸²à¸£`, size: "xs", color: "#aaaaaa", align: "center", margin: "md" } : null
        ].filter(Boolean);

    } else if (type === 'reassign_leads' && data.leadsList) {
        bodyContents = [
            { type: "text", text: "à¸£à¸²à¸¢à¸à¸²à¸£à¸—à¸µà¹ˆà¸–à¸¹à¸à¹‚à¸­à¸™à¸¢à¹‰à¸²à¸¢à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´", weight: "bold", size: "sm", align: "center" },
            { type: "separator", margin: "md" },
             createTableRow("à¸Šà¸·à¹ˆà¸­à¸¥à¸¹à¸à¸„à¹‰à¸²", "à¹€à¸‹à¸¥à¸¥à¹Œà¹€à¸”à¸´à¸¡", "à¸ªà¸–à¸²à¸™à¸°"),
             { type: "separator", margin: "sm" },
            ...data.leadsList.slice(0, 10).map(l => createTableRow(l.name, l.profiles?.full_name?.split(' ')[0] || '-', "à¹‚à¸­à¸™à¸¢à¹‰à¸²à¸¢à¹à¸¥à¹‰à¸§")),
             data.leadsList.length > 10 ? { type: "text", text: `...à¹à¸¥à¸°à¸­à¸µà¸ ${data.leadsList.length - 10} à¸£à¸²à¸¢à¸à¸²à¸£`, size: "xs", color: "#aaaaaa", align: "center", margin: "md" } : null
        ].filter(Boolean);

    } else if (type === 'followup_reminder' && data.followUps) {
        bodyContents = [
             { type: "text", text: `à¸™à¸±à¸”à¸«à¸¡à¸²à¸¢à¸›à¸£à¸°à¸ˆà¸³à¸§à¸±à¸™à¸—à¸µà¹ˆ ${dateStr}`, weight: "bold", size: "sm", align: "center" },
             { type: "separator", margin: "md" },
             ...data.followUps.slice(0, 10).map(e => ({
                type: "box",
                layout: "vertical",
                margin: "sm",
                contents: [
                    { type: "text", text: `ðŸ•’ ${new Date(e.start_time).toLocaleTimeString('th-TH', {hour:'2-digit', minute:'2-digit'})} - ${e.title}`, size: "sm", weight: "bold", color: "#333333" },
                    { type: "text", text: `à¸¥à¸¹à¸à¸„à¹‰à¸²: ${e.leads?.name || '-'}`, size: "xs", color: "#666666", margin: "xs" }
                ]
             })),
             data.followUps.length === 0 ? { type: "text", text: "à¹„à¸¡à¹ˆà¸¡à¸µà¸™à¸±à¸”à¸«à¸¡à¸²à¸¢à¸§à¸±à¸™à¸™à¸µà¹‰", size: "sm", color: "#999999", align: "center", margin: "lg" } : null
        ].filter(Boolean);

    } else {
        // Default Single Item Layout (New Lead, Update, Delete, Test)
        bodyContents = [
            {
                type: "box",
                layout: "vertical",
                contents: [
                    { type: "text", text: dateStr, weight: "bold", color: headerColor, size: "sm" },
                    { type: "text", text: timeStr + " à¸™.", size: "3xl", weight: "bold", color: "#333333", margin: "xs" }
                ]
            },
            { type: "separator", margin: "lg" },
            {
                type: "box",
                layout: "vertical",
                margin: "lg",
                spacing: "md",
                contents: [
                    data.receivedDate ? createDetailRow("à¸§à¸±à¸™à¸—à¸µà¹ˆà¸¥à¸‡à¸ˆà¸­à¸‡", receivedDateFormatted) : null,
                    data.salesName ? createDetailRow("à¸à¹ˆà¸²à¸¢à¸‚à¸²à¸¢", data.salesName) : null,
                    data.leadName ? createDetailRow("à¸Šà¸·à¹ˆà¸­à¸¥à¸¹à¸à¸„à¹‰à¸²", data.leadName) : null,
                    data.program ? createDetailRow("à¹‚à¸›à¸£à¹à¸à¸£à¸¡", data.program) : null,
                    data.phone ? createDetailRow("à¹€à¸šà¸­à¸£à¹Œà¹‚à¸—à¸£", data.phone, "#1e40af") : null,
                    
                    (type === 'update_status' || type === 'new_lead' || type === 'test') ? 
                        createDetailRow("à¸ªà¸–à¸²à¸™à¸°", data.status || "à¹ƒà¸«à¸¡à¹ˆ", statusColor) : null,

                    data.address ? createDetailRow("à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ", data.address) : null,
                    data.notes ? createDetailRow("à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸", data.notes) : null,

                     type === 'delete_lead' ? 
                        { type: "text", text: "âš ï¸ à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸–à¸¹à¸à¸¥à¸šà¸­à¸­à¸à¸ˆà¸²à¸à¸£à¸°à¸šà¸šà¹à¸¥à¹‰à¸§", margin: "xl", size: "xs", color: "#ef4444", align: "center" } : null
                ].filter(Boolean)
            }
        ];
    }

    const flexMessage = {
        type: "bubble",
        size: "giga",
        header: {
            type: "box",
            layout: "vertical",
            contents: [
                { type: "text", text: headerTitle, weight: "bold", color: "#FFFFFF", size: "lg" }
            ],
            backgroundColor: headerColor,
            paddingAll: "lg"
        },
        body: {
            type: "box",
            layout: "vertical",
            contents: bodyContents,
            paddingAll: "lg"
        },
        footer: {
            type: "box",
            layout: "vertical",
            contents: [
                { type: "button", action: { type: "uri", label: "à¹€à¸›à¸´à¸”à¹à¸­à¸›à¸žà¸¥à¸´à¹€à¸„à¸Šà¸±à¸™", uri: APP_URL }, style: "primary", color: headerColor, height: "sm" }
            ],
            paddingAll: "lg"
        }
    };

    const body = {
        to: LINE_TARGET_ID,
        messages: [
            {
                type: "flex",
                altText: altText,
                contents: flexMessage
            }
        ]
    };

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${LINE_CHANNEL_ACCESS_TOKEN}`
            },
            body: JSON.stringify(body)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`LINE API Error: ${response.status} - ${errorText}`);
        }
        console.log(`Line Notification Sent (${type})`);
    } catch (error) {
        console.error("Failed to send Line Notification", error);
    }
};

export const runConnectionTest = async (onProgress: (result: ConnectionTestResult) => void) => {
    const delay = (ms: number) => new Promise(res => setTimeout(res, ms));

    const { data: { user } } = await supabase.auth.getUser();
    const isAuthenticated = !!user;
    const userId = user?.id;

    const tests = [
        {
            name: "0. âš¡ One-Click Setup (Start Here)",
            requiresAuth: false,
            action: async () => ({
                success: true, // Always show as info/success so fix is available
                details: "à¸ªà¸„à¸£à¸´à¸›à¸•à¹Œà¸•à¸´à¸”à¸•à¸±à¹‰à¸‡à¸£à¸°à¸šà¸šà¸„à¸£à¸±à¹‰à¸‡à¹à¸£à¸: à¸ªà¸£à¹‰à¸²à¸‡à¸•à¸²à¸£à¸²à¸‡ + à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ + Admin (admin@admin / admin123)",
                fix: SQL_ONE_CLICK_SETUP
            })
        },
        {
            name: "1. à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ Supabase",
            requiresAuth: false,
            action: async () => ({
                success: true,
                details: "à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­ Supabase à¸ªà¸³à¹€à¸£à¹‡à¸ˆ (URL à¹à¸¥à¸° Key à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡)",
            })
        },
        ...['profiles', 'leads', 'calendar_events', 'lead_activities', 'programs'].map((table, i) => ({
            name: `${i + 2}. à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸•à¸²à¸£à¸²à¸‡ '${table}'`,
            requiresAuth: false,
            action: async () => {
                const { error } = await supabase.from(table).select('id', { count: 'exact', head: true });
                let fix = undefined;
                if (error && table === 'programs') {
                    fix = SQL_CREATE_PROGRAMS;
                } else if (error) {
                     fix = `à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸•à¸²à¸£à¸²à¸‡ '${table}' à¸–à¸¹à¸à¸ªà¸£à¹‰à¸²à¸‡à¸‚à¸¶à¹‰à¸™à¹ƒà¸™ Supabase Public Schema à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§`;
                }

                return {
                    success: !error,
                    details: error ? `à¹„à¸¡à¹ˆà¸žà¸šà¸•à¸²à¸£à¸²à¸‡ '${table}' à¸«à¸£à¸·à¸­à¸­à¸²à¸ˆà¹„à¸¡à¹ˆà¸¡à¸µà¸ªà¸´à¸—à¸˜à¸´à¹Œà¸­à¹ˆà¸²à¸™à¸žà¸·à¹‰à¸™à¸à¸²à¸™` : `à¸žà¸šà¸•à¸²à¸£à¸²à¸‡ '${table}'`,
                    fix: fix
                };
            }
        })),
        {
            name: "7. à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™ (Admin)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                return { 
                    success: true, 
                    details: "à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸”à¹‰à¸§à¸¢à¸•à¸±à¸§à¹€à¸­à¸‡: à¸«à¸²à¸à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸£à¸«à¸±à¸ªà¸œà¹ˆà¸²à¸™à¹à¸¥à¹‰à¸§à¹€à¸ˆà¸­ Error à¹ƒà¸«à¹‰à¹ƒà¸Šà¹‰ SQL à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡à¸™à¸µà¹‰à¹à¸à¹‰à¹„à¸‚", 
                    fix: SQL_UPDATE_USER_PASSWORD_FIX 
                };
            }
        },
        {
            name: "8. à¸—à¸”à¸ªà¸­à¸šà¸ªà¸´à¸—à¸˜à¸´à¹Œà¸•à¸²à¸£à¸²à¸‡ 'leads' (CRUD)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                return { success: true, details: "à¸‚à¹‰à¸²à¸¡à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´ (à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸ªà¸´à¸—à¸˜à¸´à¹Œ Admin à¹à¸¥à¸° Sales)", fix: RLS_LEADS_FIX };
            }
        },
        {
            name: "9. à¸—à¸”à¸ªà¸­à¸šà¸ªà¸´à¸—à¸˜à¸´à¹Œà¸•à¸²à¸£à¸²à¸‡ 'profiles' (Update Self)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                try {
                    const { data: profile, error: fetchError } = await supabase.from('profiles').select('full_name').eq('id', currentUserId!).single();
                    if (fetchError) throw new Error(`Fetch profile failed: ${fetchError.message}`);
                    
                    const { error: updateError } = await supabase.from('profiles').update({ full_name: profile.full_name }).eq('id', currentUserId!);
                    if (updateError) throw new Error(`Update failed: ${updateError.message}`);

                    return { success: true, details: "à¸ªà¸´à¸—à¸˜à¸´à¹Œ à¸­à¹ˆà¸²à¸™à¹à¸¥à¸°à¹à¸à¹‰à¹„à¸‚à¹‚à¸›à¸£à¹„à¸Ÿà¸¥à¹Œà¸•à¸±à¸§à¹€à¸­à¸‡à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡" };
                } catch (e: any) {
                    return { success: false, details: `à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§: ${e.message}`, fix: RLS_PROFILES_FIX };
                }
            }
        },
        {
            name: "10. à¸—à¸”à¸ªà¸­à¸šà¸ªà¸´à¸—à¸˜à¸´à¹Œà¸•à¸²à¸£à¸²à¸‡ 'calendar_events' (CRUD)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                try {
                    const testEvent = { title: 'RLS Test Event', start_time: new Date().toISOString(), end_time: new Date().toISOString(), salesperson_id: currentUserId! };
                    const { data, error: insertError } = await supabase.from('calendar_events').insert(testEvent).select();
                    if (insertError) throw new Error(`Insert failed: ${insertError.message}`);

                    const newEventId = data[0].id;
                    const { error: updateError } = await supabase.from('calendar_events').update({ title: 'Test Update' }).eq('id', newEventId);
                    if (updateError) throw new Error(`Update failed: ${updateError.message}`);

                    const { error: deleteError } = await supabase.from('calendar_events').delete().eq('id', newEventId);
                    if (deleteError) throw new Error(`Delete failed: ${deleteError.message}`);

                    return { success: true, details: "à¸ªà¸´à¸—à¸˜à¸´à¹Œ à¸­à¹ˆà¸²à¸™, à¹€à¸‚à¸µà¸¢à¸™, à¸¥à¸š à¹ƒà¸™à¸•à¸²à¸£à¸²à¸‡ 'calendar_events' à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡" };
                } catch (e: any) {
                    return { success: false, details: `à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§: ${e.message}`, fix: RLS_CALENDAR_FIX };
                }
            }
        },
         {
            name: "11. à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸ªà¸£à¹‰à¸²à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰ (Admin)",
            requiresAuth: true,
            action: async (currentUserId?: string) => {
                 return { 
                    success: true, 
                    details: "à¸«à¸²à¸à¸žà¸š Error 'provider_id' à¹ƒà¸«à¹‰à¸„à¸±à¸”à¸¥à¸­à¸ SQL à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡à¹„à¸›à¸£à¸±à¸™à¹ƒà¸«à¸¡à¹ˆà¹ƒà¸™ Supabase", 
                    fix: SQL_ADMIN_CREATE_USER 
                };
            }
        }
    ];

     onProgress({
        test: 'Authentication Check',
        status: isAuthenticated ? 'success' : 'info',
        details: isAuthenticated ? `à¸—à¸”à¸ªà¸­à¸šà¹ƒà¸™à¸à¸²à¸™à¸°à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰: ${user.email}` : 'à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸‚à¹‰à¸²à¸ªà¸¹à¹ˆà¸£à¸°à¸šà¸š à¸ˆà¸°à¸‚à¹‰à¸²à¸¡à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ªà¸´à¸—à¸˜à¸´à¹Œà¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ (RLS)',
    });
    await delay(300);

    for (const test of tests) {
        if (test.requiresAuth && !isAuthenticated) {
            onProgress({
                test: test.name,
                status: 'info',
                details: 'à¸‚à¹‰à¸²à¸¡à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸š RLS à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸ˆà¸²à¸à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸‚à¹‰à¸²à¸ªà¸¹à¹ˆà¸£à¸°à¸šà¸š',
            });
            continue;
        }

        onProgress({ test: test.name, status: 'pending', details: 'à¸à¸³à¸¥à¸±à¸‡à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£...' });
        await delay(300);
        const result = await test.action(userId);
        onProgress({
            test: test.name,
            status: result.success ? 'success' : 'failure',
            details: result.details,
            fix: (result as any).fix
        });
        if (!result.success && test.name.includes('à¸•à¸²à¸£à¸²à¸‡')) break;
    }
};